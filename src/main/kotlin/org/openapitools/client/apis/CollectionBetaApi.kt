/**
 * Catalog API
 *
 * Methods for collecting product/sku catalog data, categories, brands and other information. <br><br> All content that comes between {{}} keys must be replaced with the correct data before performing the request. <br><br> Common parameters that must be changed in most VTEX requests <br> {{accountName}} => Store account name <br> {{environment}} => The environment that will be called. Change for vtexcommercestable or vtexcommmercebeta <br> {{X-VTEX-API-AppKey}} => Located in the headers of the requests, user authentication key <br> {{X-VTEX-API-AppToken}} => Located in the headers of the requests, authentication password
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException

import org.openapitools.client.models.RequestBody15

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class CollectionBetaApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://{accountName}.{environment}.com.br")
        }
    }

    /**
    * Get All Collections
    * Retrieves a list of all collections matching a filter
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param page Page number 
    * @param pageSize Number of the items of the page 
    * @param orderByAsc If the items of the page are order by ascending 
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun gETAllCollections(contentType: kotlin.String, accept: kotlin.String, page: kotlin.Int, pageSize: kotlin.Int, orderByAsc: kotlin.Boolean) : Unit {
        val localVarResponse = gETAllCollectionsWithHttpInfo(contentType = contentType, accept = accept, page = page, pageSize = pageSize, orderByAsc = orderByAsc)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get All Collections
    * Retrieves a list of all collections matching a filter
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param page Page number 
    * @param pageSize Number of the items of the page 
    * @param orderByAsc If the items of the page are order by ascending 
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun gETAllCollectionsWithHttpInfo(contentType: kotlin.String, accept: kotlin.String, page: kotlin.Int, pageSize: kotlin.Int, orderByAsc: kotlin.Boolean) : ApiResponse<Unit?> {
        val localVariableConfig = gETAllCollectionsRequestConfig(contentType = contentType, accept = accept, page = page, pageSize = pageSize, orderByAsc = orderByAsc)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation gETAllCollections
    *
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param page Page number 
    * @param pageSize Number of the items of the page 
    * @param orderByAsc If the items of the page are order by ascending 
    * @return RequestConfig
    */
    fun gETAllCollectionsRequestConfig(contentType: kotlin.String, accept: kotlin.String, page: kotlin.Int, pageSize: kotlin.Int, orderByAsc: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("page", listOf(page.toString()))
                put("pageSize", listOf(pageSize.toString()))
                put("orderByAsc", listOf(orderByAsc.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType.apply { localVariableHeaders["Content-Type"] = this.toString() }
        accept.apply { localVariableHeaders["Accept"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/catalog_system/pvt/collection/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get All Inactive Collections
    * Retrieves a list of Collection IDs of the inactive Collections
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun gETAllInactiveCollections(contentType: kotlin.String, accept: kotlin.String) : Unit {
        val localVarResponse = gETAllInactiveCollectionsWithHttpInfo(contentType = contentType, accept = accept)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get All Inactive Collections
    * Retrieves a list of Collection IDs of the inactive Collections
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun gETAllInactiveCollectionsWithHttpInfo(contentType: kotlin.String, accept: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = gETAllInactiveCollectionsRequestConfig(contentType = contentType, accept = accept)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation gETAllInactiveCollections
    *
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @return RequestConfig
    */
    fun gETAllInactiveCollectionsRequestConfig(contentType: kotlin.String, accept: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType.apply { localVariableHeaders["Content-Type"] = this.toString() }
        accept.apply { localVariableHeaders["Accept"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/catalog/pvt/collection/inactive",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Collections by search terms
    * Retrieves a list of collections matching a filter
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param searchTerms String that will search for a collection related to it 
    * @param page Page number (optional)
    * @param pageSize Number of the items of the page (optional)
    * @param orderByAsc If the items of the page are order by ascending (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun gETCollectionsbyseachterms(contentType: kotlin.String, accept: kotlin.String, searchTerms: kotlin.String, page: kotlin.Int?, pageSize: kotlin.Int?, orderByAsc: kotlin.Boolean?) : Unit {
        val localVarResponse = gETCollectionsbyseachtermsWithHttpInfo(contentType = contentType, accept = accept, searchTerms = searchTerms, page = page, pageSize = pageSize, orderByAsc = orderByAsc)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get Collections by search terms
    * Retrieves a list of collections matching a filter
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param searchTerms String that will search for a collection related to it 
    * @param page Page number (optional)
    * @param pageSize Number of the items of the page (optional)
    * @param orderByAsc If the items of the page are order by ascending (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun gETCollectionsbyseachtermsWithHttpInfo(contentType: kotlin.String, accept: kotlin.String, searchTerms: kotlin.String, page: kotlin.Int?, pageSize: kotlin.Int?, orderByAsc: kotlin.Boolean?) : ApiResponse<Unit?> {
        val localVariableConfig = gETCollectionsbyseachtermsRequestConfig(contentType = contentType, accept = accept, searchTerms = searchTerms, page = page, pageSize = pageSize, orderByAsc = orderByAsc)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation gETCollectionsbyseachterms
    *
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param searchTerms String that will search for a collection related to it 
    * @param page Page number (optional)
    * @param pageSize Number of the items of the page (optional)
    * @param orderByAsc If the items of the page are order by ascending (optional)
    * @return RequestConfig
    */
    fun gETCollectionsbyseachtermsRequestConfig(contentType: kotlin.String, accept: kotlin.String, searchTerms: kotlin.String, page: kotlin.Int?, pageSize: kotlin.Int?, orderByAsc: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
                if (orderByAsc != null) {
                    put("orderByAsc", listOf(orderByAsc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType.apply { localVariableHeaders["Content-Type"] = this.toString() }
        accept.apply { localVariableHeaders["Accept"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/catalog_system/pvt/collection/search/{searchTerms}".replace("{"+"searchTerms"+"}", "$searchTerms"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Import Collection file example
    * Imports a sample of the imported XLS file. You need to save the response file to your device
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun gETImportfileexample(contentType: kotlin.String, accept: kotlin.String) : Unit {
        val localVarResponse = gETImportfileexampleWithHttpInfo(contentType = contentType, accept = accept)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Import Collection file example
    * Imports a sample of the imported XLS file. You need to save the response file to your device
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun gETImportfileexampleWithHttpInfo(contentType: kotlin.String, accept: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = gETImportfileexampleRequestConfig(contentType = contentType, accept = accept)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation gETImportfileexample
    *
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @return RequestConfig
    */
    fun gETImportfileexampleRequestConfig(contentType: kotlin.String, accept: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType.apply { localVariableHeaders["Content-Type"] = this.toString() }
        accept.apply { localVariableHeaders["Accept"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/catalog/pvt/collection/stockkeepingunit/importfileexample",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get products from a collection
    * Retrieves information about the products from a collection
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param collectionId Collection&#39;s unique identifier 
    * @param page Page number (optional, default to 2)
    * @param pageSize Number of the items of the page (optional, default to 15)
    * @param filter Filter used to refine the Collection&#39;s products (optional, default to "Pre launch")
    * @param active If the status of the product is active or not (optional, default to true)
    * @param visible If the product is visible on store or not (optional, default to true)
    * @param categoryId Product&#39;s Category unique identifier (optional, default to 12)
    * @param brandId Product&#39;s Brand unique identifier (optional, default to 3)
    * @param supplierId Product&#39;s Supplier unique identifier (optional, default to 1)
    * @param salesChannelId Product&#39;s Trade Policy unique identifier (optional, default to 1)
    * @param releaseFrom Product past release date (optional, default to "2069-11-26T15:23:00")
    * @param releaseTo Product future release date (optional, default to "2069-11-26T15:23:00")
    * @param specificationProduct Product Specification Field Value. You must also fill in &#x60;SpecificationFieldId&#x60; to use this parameter. (optional, default to "M")
    * @param specificationFieldId Product Specification Field unique identifier (optional, default to 40)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun gETProductsfromacollection(contentType: kotlin.String, accept: kotlin.String, collectionId: kotlin.Int, page: kotlin.Int?, pageSize: kotlin.Int?, filter: kotlin.String?, active: kotlin.Boolean?, visible: kotlin.Boolean?, categoryId: kotlin.Int?, brandId: kotlin.Int?, supplierId: kotlin.Int?, salesChannelId: kotlin.Int?, releaseFrom: kotlin.String?, releaseTo: kotlin.String?, specificationProduct: kotlin.String?, specificationFieldId: kotlin.Int?) : Unit {
        val localVarResponse = gETProductsfromacollectionWithHttpInfo(contentType = contentType, accept = accept, collectionId = collectionId, page = page, pageSize = pageSize, filter = filter, active = active, visible = visible, categoryId = categoryId, brandId = brandId, supplierId = supplierId, salesChannelId = salesChannelId, releaseFrom = releaseFrom, releaseTo = releaseTo, specificationProduct = specificationProduct, specificationFieldId = specificationFieldId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get products from a collection
    * Retrieves information about the products from a collection
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param collectionId Collection&#39;s unique identifier 
    * @param page Page number (optional, default to 2)
    * @param pageSize Number of the items of the page (optional, default to 15)
    * @param filter Filter used to refine the Collection&#39;s products (optional, default to "Pre launch")
    * @param active If the status of the product is active or not (optional, default to true)
    * @param visible If the product is visible on store or not (optional, default to true)
    * @param categoryId Product&#39;s Category unique identifier (optional, default to 12)
    * @param brandId Product&#39;s Brand unique identifier (optional, default to 3)
    * @param supplierId Product&#39;s Supplier unique identifier (optional, default to 1)
    * @param salesChannelId Product&#39;s Trade Policy unique identifier (optional, default to 1)
    * @param releaseFrom Product past release date (optional, default to "2069-11-26T15:23:00")
    * @param releaseTo Product future release date (optional, default to "2069-11-26T15:23:00")
    * @param specificationProduct Product Specification Field Value. You must also fill in &#x60;SpecificationFieldId&#x60; to use this parameter. (optional, default to "M")
    * @param specificationFieldId Product Specification Field unique identifier (optional, default to 40)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun gETProductsfromacollectionWithHttpInfo(contentType: kotlin.String, accept: kotlin.String, collectionId: kotlin.Int, page: kotlin.Int?, pageSize: kotlin.Int?, filter: kotlin.String?, active: kotlin.Boolean?, visible: kotlin.Boolean?, categoryId: kotlin.Int?, brandId: kotlin.Int?, supplierId: kotlin.Int?, salesChannelId: kotlin.Int?, releaseFrom: kotlin.String?, releaseTo: kotlin.String?, specificationProduct: kotlin.String?, specificationFieldId: kotlin.Int?) : ApiResponse<Unit?> {
        val localVariableConfig = gETProductsfromacollectionRequestConfig(contentType = contentType, accept = accept, collectionId = collectionId, page = page, pageSize = pageSize, filter = filter, active = active, visible = visible, categoryId = categoryId, brandId = brandId, supplierId = supplierId, salesChannelId = salesChannelId, releaseFrom = releaseFrom, releaseTo = releaseTo, specificationProduct = specificationProduct, specificationFieldId = specificationFieldId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation gETProductsfromacollection
    *
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param collectionId Collection&#39;s unique identifier 
    * @param page Page number (optional, default to 2)
    * @param pageSize Number of the items of the page (optional, default to 15)
    * @param filter Filter used to refine the Collection&#39;s products (optional, default to "Pre launch")
    * @param active If the status of the product is active or not (optional, default to true)
    * @param visible If the product is visible on store or not (optional, default to true)
    * @param categoryId Product&#39;s Category unique identifier (optional, default to 12)
    * @param brandId Product&#39;s Brand unique identifier (optional, default to 3)
    * @param supplierId Product&#39;s Supplier unique identifier (optional, default to 1)
    * @param salesChannelId Product&#39;s Trade Policy unique identifier (optional, default to 1)
    * @param releaseFrom Product past release date (optional, default to "2069-11-26T15:23:00")
    * @param releaseTo Product future release date (optional, default to "2069-11-26T15:23:00")
    * @param specificationProduct Product Specification Field Value. You must also fill in &#x60;SpecificationFieldId&#x60; to use this parameter. (optional, default to "M")
    * @param specificationFieldId Product Specification Field unique identifier (optional, default to 40)
    * @return RequestConfig
    */
    fun gETProductsfromacollectionRequestConfig(contentType: kotlin.String, accept: kotlin.String, collectionId: kotlin.Int, page: kotlin.Int?, pageSize: kotlin.Int?, filter: kotlin.String?, active: kotlin.Boolean?, visible: kotlin.Boolean?, categoryId: kotlin.Int?, brandId: kotlin.Int?, supplierId: kotlin.Int?, salesChannelId: kotlin.Int?, releaseFrom: kotlin.String?, releaseTo: kotlin.String?, specificationProduct: kotlin.String?, specificationFieldId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
                if (filter != null) {
                    put("Filter", listOf(filter.toString()))
                }
                if (active != null) {
                    put("Active", listOf(active.toString()))
                }
                if (visible != null) {
                    put("Visible", listOf(visible.toString()))
                }
                if (categoryId != null) {
                    put("CategoryId", listOf(categoryId.toString()))
                }
                if (brandId != null) {
                    put("BrandId", listOf(brandId.toString()))
                }
                if (supplierId != null) {
                    put("SupplierId", listOf(supplierId.toString()))
                }
                if (salesChannelId != null) {
                    put("SalesChannelId", listOf(salesChannelId.toString()))
                }
                if (releaseFrom != null) {
                    put("ReleaseFrom", listOf(releaseFrom.toString()))
                }
                if (releaseTo != null) {
                    put("ReleaseTo", listOf(releaseTo.toString()))
                }
                if (specificationProduct != null) {
                    put("SpecificationProduct", listOf(specificationProduct.toString()))
                }
                if (specificationFieldId != null) {
                    put("SpecificationFieldId", listOf(specificationFieldId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType.apply { localVariableHeaders["Content-Type"] = this.toString() }
        accept.apply { localVariableHeaders["Accept"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/catalog/pvt/collection/{collectionId}/products".replace("{"+"collectionId"+"}", "$collectionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Add products to Collection by imported file
    * Adds products to a collection from the request body file. The file must be an imported template
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param collectionId Collection&#39;s unique identifier 
    * @param file XLS file with information about products to be added to a Collection. The file must be an imported template from [Import Collection file example](https://developers.vtex.com/vtex-developer-docs/reference/get-importfileexample) endpoint. (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun pOSTAddproductsbyimportfile(contentType: kotlin.String, accept: kotlin.String, collectionId: kotlin.Int, file: kotlin.Any?) : Unit {
        val localVarResponse = pOSTAddproductsbyimportfileWithHttpInfo(contentType = contentType, accept = accept, collectionId = collectionId, file = file)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Add products to Collection by imported file
    * Adds products to a collection from the request body file. The file must be an imported template
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param collectionId Collection&#39;s unique identifier 
    * @param file XLS file with information about products to be added to a Collection. The file must be an imported template from [Import Collection file example](https://developers.vtex.com/vtex-developer-docs/reference/get-importfileexample) endpoint. (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun pOSTAddproductsbyimportfileWithHttpInfo(contentType: kotlin.String, accept: kotlin.String, collectionId: kotlin.Int, file: kotlin.Any?) : ApiResponse<Unit?> {
        val localVariableConfig = pOSTAddproductsbyimportfileRequestConfig(contentType = contentType, accept = accept, collectionId = collectionId, file = file)

        return request<Map<String, Any?>, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation pOSTAddproductsbyimportfile
    *
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param collectionId Collection&#39;s unique identifier 
    * @param file XLS file with information about products to be added to a Collection. The file must be an imported template from [Import Collection file example](https://developers.vtex.com/vtex-developer-docs/reference/get-importfileexample) endpoint. (optional)
    * @return RequestConfig
    */
    fun pOSTAddproductsbyimportfileRequestConfig(contentType: kotlin.String, accept: kotlin.String, collectionId: kotlin.Int, file: kotlin.Any?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("file" to file)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        contentType.apply { localVariableHeaders["Content-Type"] = this.toString() }
        accept.apply { localVariableHeaders["Accept"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/catalog/pvt/collection/{collectionId}/stockkeepingunit/importinsert".replace("{"+"collectionId"+"}", "$collectionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create Collection
    * Creates a new collection
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param requestBody15  
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun pOSTCreateCollection(contentType: kotlin.String, accept: kotlin.String, requestBody15: RequestBody15) : Unit {
        val localVarResponse = pOSTCreateCollectionWithHttpInfo(contentType = contentType, accept = accept, requestBody15 = requestBody15)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create Collection
    * Creates a new collection
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param requestBody15  
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun pOSTCreateCollectionWithHttpInfo(contentType: kotlin.String, accept: kotlin.String, requestBody15: RequestBody15) : ApiResponse<Unit?> {
        val localVariableConfig = pOSTCreateCollectionRequestConfig(contentType = contentType, accept = accept, requestBody15 = requestBody15)

        return request<RequestBody15, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation pOSTCreateCollection
    *
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param requestBody15  
    * @return RequestConfig
    */
    fun pOSTCreateCollectionRequestConfig(contentType: kotlin.String, accept: kotlin.String, requestBody15: RequestBody15) : RequestConfig<RequestBody15> {
        val localVariableBody = requestBody15
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType.apply { localVariableHeaders["Content-Type"] = this.toString() }
        accept.apply { localVariableHeaders["Accept"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/catalog/pvt/collection/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Remove products from Collection by imported file
    * Removes products from a collection from the request body file. The file must be an imported template
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param collectionId Collection&#39;s unique identifier 
    * @param file XLS file with information about products to be added to a Collection. The file must be an imported template from [Import Collection file example](https://developers.vtex.com/vtex-developer-docs/reference/get-importfileexample) endpoint. (optional)
    * @return void
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun pOSTRemoveproductsbyimportfile(contentType: kotlin.String, accept: kotlin.String, collectionId: kotlin.Int, file: kotlin.Any?) : Unit {
        val localVarResponse = pOSTRemoveproductsbyimportfileWithHttpInfo(contentType = contentType, accept = accept, collectionId = collectionId, file = file)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Remove products from Collection by imported file
    * Removes products from a collection from the request body file. The file must be an imported template
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param collectionId Collection&#39;s unique identifier 
    * @param file XLS file with information about products to be added to a Collection. The file must be an imported template from [Import Collection file example](https://developers.vtex.com/vtex-developer-docs/reference/get-importfileexample) endpoint. (optional)
    * @return ApiResponse<Unit?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Throws(IllegalStateException::class, IOException::class)
    fun pOSTRemoveproductsbyimportfileWithHttpInfo(contentType: kotlin.String, accept: kotlin.String, collectionId: kotlin.Int, file: kotlin.Any?) : ApiResponse<Unit?> {
        val localVariableConfig = pOSTRemoveproductsbyimportfileRequestConfig(contentType = contentType, accept = accept, collectionId = collectionId, file = file)

        return request<Map<String, Any?>, Unit>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation pOSTRemoveproductsbyimportfile
    *
    * @param contentType Type of the content being sent 
    * @param accept HTTP Client Negotiation _Accept_ Header. Indicates the types of responses the client can understand  
    * @param collectionId Collection&#39;s unique identifier 
    * @param file XLS file with information about products to be added to a Collection. The file must be an imported template from [Import Collection file example](https://developers.vtex.com/vtex-developer-docs/reference/get-importfileexample) endpoint. (optional)
    * @return RequestConfig
    */
    fun pOSTRemoveproductsbyimportfileRequestConfig(contentType: kotlin.String, accept: kotlin.String, collectionId: kotlin.Int, file: kotlin.Any?) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("file" to file)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        contentType.apply { localVariableHeaders["Content-Type"] = this.toString() }
        accept.apply { localVariableHeaders["Accept"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/catalog/pvt/collection/{collectionId}/stockkeepingunit/importexclude".replace("{"+"collectionId"+"}", "$collectionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
